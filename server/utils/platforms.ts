import { $fetch } from 'ofetch'

const SPOTIFY_API = 'https://api.spotify.com/v1'
const APPLE_MUSIC_API = 'https://api.music.apple.com/v1'
const SOUNDCLOUD_API = 'https://api.soundcloud.com'
const YOUTUBE_API = 'https://www.googleapis.com/youtube/v3'

export type SupportedPlatform = 'spotify' | 'apple' | 'soundcloud' | 'youtube'

export interface TrackIdentity {
  title: string
  artist?: string
  spotifyUri?: string | null
  spotifyUrl?: string | null
  appleMusicId?: string | null
  appleMusicUrl?: string | null
  soundcloudId?: string | null
  soundcloudUrl?: string | null
}

const safeFetch = async <T>(handler: () => Promise<T>): Promise<T | null> => {
  try {
    return await handler()
  }
  catch (error) {
    console.error('[platforms] request failed', error)
    return null
  }
}

export const detectPlatform = (url: string): SupportedPlatform | null => {
  if (url.includes('spotify.com') || url.startsWith('spotify:')) {
    return 'spotify'
  }
  if (url.includes('music.apple.com') || url.includes('itunes.apple.com')) {
    return 'apple'
  }
  if (url.includes('soundcloud.com')) {
    return 'soundcloud'
  }
  if (url.includes('youtube.com') || url.includes('youtu.be')) {
    return 'youtube'
  }
  return null
}

const chunk = <T>(items: T[], size: number) => {
  const result: T[][] = []
  for (let i = 0; i < items.length; i += size) {
    result.push(items.slice(i, i + size))
  }
  return result
}

// Spotify helpers
const extractSpotifyId = (url: string) => {
  const directMatch = url.match(/track\/([A-Za-z0-9]+)/)
  if (directMatch?.[1]) {
    return directMatch[1]
  }
  const uriMatch = url.match(/spotify:track:([A-Za-z0-9]+)/)
  return uriMatch?.[1] ?? null
}

export const fetchSpotifyMetadataFromUrl = async (url: string, token?: string): Promise<TrackIdentity | null> => {
  if (!token) {
    return null
  }
  const id = extractSpotifyId(url)
  if (!id) {
    return null
  }
  return safeFetch(async () => {
    const data = await $fetch<{ name: string; artists: Array<{ name: string }>; uri: string }>(`${SPOTIFY_API}/tracks/${id}`, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    })

    return {
      title: data.name,
      artist: data.artists?.[0]?.name,
      spotifyUri: data.uri
    } satisfies TrackIdentity
  })
}

export const searchSpotifyTrack = async (query: string, token?: string): Promise<TrackIdentity | null> => {
  if (!token || !query) {
    return null
  }
  return safeFetch(async () => {
    const data = await $fetch<{ tracks: { items: Array<{ name: string; artists: Array<{ name: string }>; uri: string, external_urls: { spotify: string } }> } }>(`${SPOTIFY_API}/search`, {
      query: {
        q: query,
        type: 'track',
        limit: 1
      },
      headers: {
        Authorization: `Bearer ${token}`
      }
    })

    const item = data.tracks.items[0]
    if (!item) {
      return null
    }

    return {
      title: item.name,
      artist: item.artists?.[0]?.name,
      spotifyUri: item.uri,
      spotifyUrl: item.external_urls.spotify
    } satisfies TrackIdentity
  })
}

export const createSpotifyPlaylist = async (name: string, trackUris: string[], token?: string, userId?: string): Promise<string | null> => {
  if (!token || !userId) {
    return null
  }

  return safeFetch(async () => {
    const playlist = await $fetch<{ id: string }>(`${SPOTIFY_API}/users/${userId}/playlists`, {
      method: 'POST',
      body: {
        name,
        description: 'Auto-generated by BMAT tracks',
        public: false
      },
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    })

    if (trackUris.length) {
      const chunks = chunk(trackUris, 100)
      for (const part of chunks) {
        await $fetch(`${SPOTIFY_API}/playlists/${playlist.id}/tracks`, {
          method: 'POST',
          body: {
            uris: part
          },
          headers: {
            Authorization: `Bearer ${token}`
          }
        })
      }
    }

    return playlist.id
  })
}

// Apple helpers
const extractAppleId = (url: string) => {
  // 1. Prefer track ID (?i=...)
  const trackMatch = url.match(/[?&]i=(\d+)/)
  if (trackMatch) {
    return trackMatch[1]
  }

  // 2. Fallback: last numeric path segment
  const segments = url.split('/')
  const last = segments.pop()

  if (last) {
    const cleanLast = last.split('?')[0]
    if (/^\d+$/.test(cleanLast)) {
      return cleanLast
    }
  }

  return null
}

const getAppleStorefront = (url: string) => {
  const match = url.match(/music\.apple\.com\/(\w+)\//)
  return match?.[1] ?? 'us'
}

export const fetchAppleMetadataFromUrl = async (url: string, developerToken?: string): Promise<TrackIdentity | null> => {
  if (!developerToken) {
    return null
  }
  const id = extractAppleId(url)
  const storefront = getAppleStorefront(url)
  if (!id) {
    return null
  }
  return safeFetch(async () => {
    const data = await $fetch<{ data: Array<{ id: string; attributes: { name: string; artistName: string, url: string } }> }>(`${APPLE_MUSIC_API}/catalog/${storefront}/songs/${id}`, {
      headers: {
        Authorization: `Bearer ${developerToken}`
      }
    })

    const item = data.data[0]
    if (!item) {
      return null
    }

    return {
      title: item.attributes.name,
      artist: item.attributes.artistName,
      appleMusicId: item.id,
      appleMusicUrl: item.attributes.url
    } satisfies TrackIdentity
  })
}

export const searchAppleTrack = async (query: string, developerToken?: string): Promise<TrackIdentity | null> => {
  if (!query || !developerToken) {
    return null
  }
  return safeFetch(async () => {
    const data = await $fetch<{ results: { songs: { data: Array<{ id: string, attributes: { name: string, artistName: string, url: string } }> } } }>(`${APPLE_MUSIC_API}/catalog/us/search`, {
      query: {
        term: query,
        types: 'songs',
        limit: 1
      },
      headers: {
        Authorization: `Bearer ${developerToken}`
      }
    })

    const item = data.results.songs?.data[0]
    if (!item) {
      return null
    }

    return {
      title: item.attributes.name,
      artist: item.attributes.artistName,
      appleMusicId: item.id,
      appleMusicUrl: item.attributes.url
    } satisfies TrackIdentity
  })
}

export const createApplePlaylist = async (name: string, trackIds: string[], developerToken?: string, userToken?: string): Promise<string | null> => {
  if (!developerToken || !userToken) {
    return null
  }

  return safeFetch(async () => {
    const playlist = await $fetch<{ data: Array<{ id: string }> }>(`${APPLE_MUSIC_API}/me/library/playlists`, {
      method: 'POST',
      body: {
        attributes: {
          name,
          description: 'Auto-generated by BMAT tracks'
        }
      },
      headers: {
        Authorization: `Bearer ${developerToken}`,
        'Music-User-Token': userToken
      }
    })

    const playlistId = playlist.data[0]?.id
    if (!playlistId) {
      return null
    }

    if (trackIds.length) {
      const payload = trackIds.map(id => ({ id, type: 'songs' }))
      const chunks = chunk(payload, 100)
      for (const part of chunks) {
        await $fetch(`${APPLE_MUSIC_API}/me/library/playlists/${playlistId}/tracks`, {
          method: 'POST',
          body: {
            data: part
          },
          headers: {
            Authorization: `Bearer ${developerToken}`,
            'Music-User-Token': userToken
          }
        })
      }
    }

    return playlistId
  })
}

// SoundCloud helpers
export const resolveSoundcloudTrack = async (url: string, clientId?: string, token?: string): Promise<TrackIdentity | null> => {
  if (!clientId && !token) {
    return null
  }

  const fetchWithClientId = () => $fetch<{ title: string; user: { username: string }; id: number }>(`${SOUNDCLOUD_API}/resolve`, {
    query: {
      url,
      client_id: clientId
    }
  })

  const fetchWithToken = () => $fetch<{ title: string; user: { username: string }; id: number }>(`${SOUNDCLOUD_API}/resolve`, {
    query: { url },
    headers: {
      Authorization: `OAuth ${token}`
    }
  })

  let data: { title: string; user: { username: string }; id: number } | null = null

  if (clientId) {
    data = await safeFetch(fetchWithClientId)
  }

  if (!data && token) {
    data = await safeFetch(fetchWithToken)
  }

  if (!data) {
    return null
  }

  return {
    title: data.title,
    artist: data.user?.username,
    soundcloudId: String(data.id)
  } satisfies TrackIdentity
}

export const searchSoundcloudTrack = async (query: string, clientId?: string, token?: string): Promise<TrackIdentity | null> => {
  if (!query) {
    return null
  }

  const fetchWithToken = () => $fetch<Array<{ title: string; user: { username: string }; id: number, permalink_url: string }>>(`${SOUNDCLOUD_API}/tracks`, {
    query: {
      q: query,
      limit: 1
    },
    headers: {
      Authorization: `OAuth ${token}`
    }
  })

  let data: Array<{ title: string; user: { username: string }; id: number, permalink_url: string }> | null = null

  if (token) {
    data = await safeFetch(fetchWithToken)
  }

  if (!data || data.length === 0) {
    return null
  }

  const item = data[0]

  if (!item) {
    return null
  }

  return {
    title: item.title,
    artist: item.user?.username,
    soundcloudId: String(item.id),
    soundcloudUrl: String(item.permalink_url)
  } satisfies TrackIdentity
}

export const createSoundcloudPlaylist = async (name: string, trackIds: string[], token?: string): Promise<{ id: string | null, url: string } | null> => {
  if (!token) {
    return null
  }

  return safeFetch(async () => {
    const playlist = await $fetch<{ id: string, permalink_url: string }>(`${SOUNDCLOUD_API}/playlists`, {
      method: 'POST',
      headers: {
        Authorization: `OAuth ${token}`
      },
      body: {
        playlist: {
          title: name,
          sharing: 'public',
          tracks: trackIds.map(id => ({ id: Number(id) }))
        }
      }
    })

    return {
      id: playlist.id,
      url: playlist.permalink_url
    }
  })
}

// YouTube helpers
const extractYouTubeId = (url: string) => {
  const short = url.match(/youtu.be\/([\w-]+)/)
  if (short?.[1]) {
    return short[1]
  }
  const param = url.match(/[?&]v=([\w-]+)/)
  return param?.[1] ?? null
}

export const fetchYouTubeMetadataFromUrl = async (url: string, apiKey?: string): Promise<TrackIdentity | null> => {
  if (!apiKey) {
    return null
  }
  const id = extractYouTubeId(url)
  if (!id) {
    return null
  }
  return safeFetch(async () => {
    const data = await $fetch<{ items: Array<{ snippet: { title: string, channelTitle: string } }> }>(`${YOUTUBE_API}/videos`, {
      query: {
        id,
        part: 'snippet'
      },
      headers: {
        Authorization: `Bearer ${apiKey}`
      }
    })

    const item = data.items[0]
    if (!item) {
      return null
    }

    return {
      title: item.snippet.title,
      artist: item.snippet.channelTitle
    } satisfies TrackIdentity
  })
}
